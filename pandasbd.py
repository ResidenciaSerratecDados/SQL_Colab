# -*- coding: utf-8 -*-
"""PandasBD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11wUDcGD33wWnmdqm7iFtcJrTe09SsoFK
"""

#exemplo utilização
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#Criando um DataFrame
data = {
    'Nome': ['Ana', 'João', 'Maria'],
    'Idade': [25, 30, 28],
    'Salario': [5000, 7000, 6000]
}
df = pd.DataFrame(data)

print(df.head())

print(df.info())

print(df.describe())

#Criando um array
arr = np.array([1, 2, 3, 4, 5])

#operações vetorizadas
print(arr + 10) # soma 10 a cada elemento
print(arr - 1) # subtrai 1 de cada elemento
print(arr * 2) # multiplica cada elemento por 2
print(arr ** 2) # eleva cada elemento por 2
print(arr / 2) # divide cada elemento por 2

# 1 - criação de dados fictícios com NumPy
np.random.seed(42)
meses = np.array(['Jan', 'Fev', 'Mar', 'Abr', 'Mai'])
vendas = np.random.randint(100, 500, size=5)
custos = vendas * np.random.uniform(0.3, 0.7, size=5)
#escolher numero aleatorio randômico

print(meses)
print(vendas)
print(custos)

# 2 - Conversão para DataFrame do Pandas
dados = pd.DataFrame({
    'Mes': meses,
    'Vendas (R$)': vendas,
    'Custos (R$)': np.round(custos,2),
    'Clientes': np.random.poisson(lam=50,size=5) #escolher numero aleatorio randômico
})
print(dados)

dados['Lucro (R$)'] = dados['Vendas (R$)'] - dados['Custos (R$)'] # adição de colouna
print(dados)

dados['Teste (R$)'] = dados['Vendas (R$)'] * dados['Lucro (R$)'] # adição de colouna
print(dados)

dados['Margem %'] = np.round((dados['Lucro (R$)']/ dados['Vendas (R$)']) * 100, 1) #Arredondamento para 1 casa decimal
print(dados)

carteira_A = [0.01, 0.02, -0.015, 0.03, 0.005]
variancia_A = np.var(carteira_A)
print('Variância:', variancia_A)
desvio_padrao_A = np.std(carteira_A)
print('Desvio padrão:', desvio_padrao_A)

#criar carteiras, e imprima a variância e os desvio padrão

carteira_B = [0.012, 0.015, -0.01, 0.025, 0.008]
carteira_C = [0.1, 0.025, 0.02, 0.025, 0.027, 0.03]
carteira_D = [0.1, 0.027, 0.03, 0.0225, 0.023, 0.03]
carteira_E = [0.1, 0.02, 0.03, 0.04, 0.05, 0.06]
carteira_F = [-0.1, -0.02, -0.03, -0.035, -0.04, -0.055]

#VARIÂNCIAS
print('Variância Carteira B:', np.var(carteira_B))
print('Variância Carteira C:', np.var(carteira_C))
print('Variância Carteira D:', np.var(carteira_D))
print('Variância Carteira E:', np.var(carteira_E))
print('Variância Carteira F:', np.var(carteira_F))

#DESVIO PADRÃO
print('Desvio padrão Carteira B:', np.std(carteira_B))
print('Desvio padrão Carteira C:', np.std(carteira_C))
print('Desvio padrão Carteira D:', np.std(carteira_D))
print('Desvio padrão Carteira E:', np.std(carteira_E))
print('Desvio padrão Carteira F:', np.std(carteira_F))

#COVARIÂNCIA
CovariaciaAB = np.cov(carteira_A, carteira_B, bias=True)[0][1]
Covariacia_AB = np.cov(carteira_A, carteira_B, bias=False)[0][1]
print("Covariância entre A e B:",CovariaciaAB)
print("Covariância entre A e B:",Covariacia_AB)

'''Imprima as seguintes covariancias:

Entre C e D populacional
Entre E e F por amostragem'''

Covariancia_Amostral_CD = np.cov(carteira_C, carteira_D)
n = len(carteira_C)
Covariancia_Populacional_CD = Covariancia_Amostral_CD[0, 1] * (n - 1) / n
Covariancia_Amostral_EF = np.cov(carteira_E, carteira_F, bias=True)[0][1]
print("Covariância entre C e D populacional:",Covariancia_Populacional_CD)
print("Covariância entre E e F por amostragem:",Covariancia_Amostral_EF)

salarios={'Salários':[10,20,30,40,50,60,70,80,90,100,5]}
df=pd.DataFrame(salarios)
display(df)

assimetria=df['Salários'].skew()
media=df['Salários'].mean()
mediana=df['Salários'].median()
print('Assimetria:',assimetria)
print('Média:',media)
print('Mediana:',mediana)

#Distribuições simétrica e assimétrica

if -0.5 <= assimetria <= 0.5:
    print('A distribuição é simétrica')
elif assimetria > -0.5:
    print('A distribuição é assimétrica positiva')
else:
    print('A distribuição é assimétrica negativa')

#Curtose
curtose=df['Salários'].kurtosis()
print('Curtose:',curtose)

'''Curtose é uma medida que mede o GRAU DE CONCENTRAÇÃO dos dados ao redor da MÉDIA. No Pandas, isso é visto pelo método kurtosis() e nos ajuda a ver os "níveis de curtose" que indicam a presença ou ausência de outliers.

Como vou interpretar meus dados:

Curtose >= 2.5 e Curtose <= 3.5: MESOCÚRTICA (distribuição normal, dados bem distribuídos em torno da média);

Curtose < 2.5: PLATICÚRTICA (dados mais dispersos; presença comum de outliers);

Curtose > 3.5: LEPTOCÚRTICA (dados MUITO concentrados na média; outliers MUITO presentes).'''

if 2.5 <= curtose <= 3.5:
    print('A distribuição é MESOCÚRTICA')
elif curtose < 2.5:
    print('A distribuição é PLATIOCÚRTICA')
else:
    print('A distribuição é LEPTOCÚRTICA')

plt.boxplot(df['Salários'])
plt.title('Boxplot dos Salários')
plt.ylabel('Salário')
plt.show()